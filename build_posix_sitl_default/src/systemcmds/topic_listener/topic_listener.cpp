

/****************************************************************************
 *
 *   Copyright (c) 2015 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file topic_listener.cpp
 *
 * Autogenerated by Tools/generate_listener.py
 *
 * Tool for listening to topics when running flight stack on linux.
 */

#include <px4_middleware.h>
#include <px4_app.h>
#include <px4_config.h>
#include <uORB/uORB.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>

#ifndef PRIu64
#define PRIu64 "llu"
#endif

#ifndef PRId64
#define PRId64 "lld"
#endif


#include <uORB/topics/multirotor_motor_limits.h>
#include <uORB/topics/sensor_baro.h>
#include <uORB/topics/home_position.h>
#include <uORB/topics/offboard_control_mode.h>
#include <uORB/topics/sensor_mag.h>
#include <uORB/topics/test_motor.h>
#include <uORB/topics/vtol_vehicle_status.h>
#include <uORB/topics/esc_report.h>
#include <uORB/topics/debug_key_value.h>
#include <uORB/topics/wind_estimate.h>
#include <uORB/topics/actuator_controls_1.h>
#include <uORB/topics/hil_sensor.h>
#include <uORB/topics/geofence_result.h>
#include <uORB/topics/fence.h>
#include <uORB/topics/camera_trigger.h>
#include <uORB/topics/uavcan_parameter_request.h>
#include <uORB/topics/mc_virtual_rates_setpoint.h>
#include <uORB/topics/sensor_combined.h>
#include <uORB/topics/actuator_controls_2.h>
#include <uORB/topics/output_pwm.h>
#include <uORB/topics/ekf2_replay.h>
#include <uORB/topics/sensor_accel.h>
#include <uORB/topics/telemetry_status.h>
#include <uORB/topics/actuator_controls_virtual_fw.h>
#include <uORB/topics/mc_virtual_attitude_setpoint.h>
#include <uORB/topics/fence_vertex.h>
#include <uORB/topics/mission_result.h>
#include <uORB/topics/fw_virtual_rates_setpoint.h>
#include <uORB/topics/system_power.h>
#include <uORB/topics/vehicle_local_position.h>
#include <uORB/topics/att_pos_mocap.h>
#include <uORB/topics/tecs_status.h>
#include <uORB/topics/vehicle_status.h>
#include <uORB/topics/input_rc.h>
#include <uORB/topics/vehicle_attitude.h>
#include <uORB/topics/safety.h>
#include <uORB/topics/vehicle_rates_setpoint.h>
#include <uORB/topics/estimator_status.h>
#include <uORB/topics/vehicle_global_velocity_setpoint.h>
#include <uORB/topics/vehicle_land_detected.h>
#include <uORB/topics/parameter_update.h>
#include <uORB/topics/actuator_controls_0.h>
#include <uORB/topics/satellite_info.h>
#include <uORB/topics/vehicle_attitude_setpoint.h>
#include <uORB/topics/esc_status.h>
#include <uORB/topics/mission.h>
#include <uORB/topics/optical_flow.h>
#include <uORB/topics/vision_position_estimate.h>
#include <uORB/topics/battery_status.h>
#include <uORB/topics/vehicle_command_ack.h>
#include <uORB/topics/actuator_controls_virtual_mc.h>
#include <uORB/topics/uavcan_parameter_value.h>
#include <uORB/topics/ekf2_innovations.h>
#include <uORB/topics/filtered_bottom_flow.h>
#include <uORB/topics/encoders.h>
#include <uORB/topics/control_state.h>
#include <uORB/topics/time_offset.h>
#include <uORB/topics/manual_control_setpoint.h>
#include <uORB/topics/servorail_status.h>
#include <uORB/topics/fw_virtual_attitude_setpoint.h>
#include <uORB/topics/rc_parameter_map.h>
#include <uORB/topics/actuator_controls_3.h>
#include <uORB/topics/mc_att_ctrl_status.h>
#include <uORB/topics/distance_sensor.h>
#include <uORB/topics/rc_channels.h>
#include <uORB/topics/sensor_gyro.h>
#include <uORB/topics/subsystem_info.h>
#include <uORB/topics/actuator_direct.h>
#include <uORB/topics/vehicle_gps_position.h>
#include <uORB/topics/vehicle_control_mode.h>
#include <uORB/topics/vehicle_command.h>
#include <uORB/topics/vehicle_global_position.h>
#include <uORB/topics/vehicle_force_setpoint.h>
#include <uORB/topics/navigation_capabilities.h>
#include <uORB/topics/actuator_outputs.h>
#include <uORB/topics/differential_pressure.h>
#include <uORB/topics/airspeed.h>
#include <uORB/topics/actuator_armed.h>

extern "C" __EXPORT int listener_main(int argc, char *argv[]);

int listener_main(int argc, char *argv[]) {
	int sub = -1;
	orb_id_t ID;
	if(argc < 2) {
		printf("need at least two arguments: topic name. [optional number of messages to print]\n");
		return 1;
	}

	unsigned num_msgs = (argc > 2) ? atoi(argv[2]) : 1;
	if (strncmp(argv[1],"multirotor_motor_limits",50) == 0) {
		sub = orb_subscribe(ORB_ID(multirotor_motor_limits));
		ID = ORB_ID(multirotor_motor_limits);
		struct multirotor_motor_limits_s container;
		memset(&container, 0, sizeof(container));
	} else if (strncmp(argv[1],"sensor_baro",50) == 0) {
		sub = orb_subscribe(ORB_ID(sensor_baro));
		ID = ORB_ID(sensor_baro);
		struct sensor_baro_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: sensor_baro #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("pressure: %8.4f\n",(double)container.pressure);
			printf("altitude: %8.4f\n",(double)container.altitude);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			}
		}
	} else if (strncmp(argv[1],"home_position",50) == 0) {
		sub = orb_subscribe(ORB_ID(home_position));
		ID = ORB_ID(home_position);
		struct home_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: home_position #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("direction_x: %8.4f\n",(double)container.direction_x);
			printf("direction_y: %8.4f\n",(double)container.direction_y);
			printf("direction_z: %8.4f\n",(double)container.direction_z);
			}
		}
	} else if (strncmp(argv[1],"offboard_control_mode",50) == 0) {
		sub = orb_subscribe(ORB_ID(offboard_control_mode));
		ID = ORB_ID(offboard_control_mode);
		struct offboard_control_mode_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: offboard_control_mode #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("ignore_thrust: %s\n",container.ignore_thrust ? "True" : "False");
			printf("ignore_attitude: %s\n",container.ignore_attitude ? "True" : "False");
			printf("ignore_bodyrate: %s\n",container.ignore_bodyrate ? "True" : "False");
			printf("ignore_position: %s\n",container.ignore_position ? "True" : "False");
			printf("ignore_velocity: %s\n",container.ignore_velocity ? "True" : "False");
			printf("ignore_acceleration_force: %s\n",container.ignore_acceleration_force ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"sensor_mag",50) == 0) {
		sub = orb_subscribe(ORB_ID(sensor_mag));
		ID = ORB_ID(sensor_mag);
		struct sensor_mag_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: sensor_mag #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("range_ga: %8.4f\n",(double)container.range_ga);
			printf("scaling: %8.4f\n",(double)container.scaling);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("x_raw: %d\n",(int)container.x_raw);
			printf("y_raw: %d\n",(int)container.y_raw);
			printf("z_raw: %d\n",(int)container.z_raw);
			}
		}
	} else if (strncmp(argv[1],"test_motor",50) == 0) {
		sub = orb_subscribe(ORB_ID(test_motor));
		ID = ORB_ID(test_motor);
		struct test_motor_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: test_motor #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("motor_number: %u\n",container.motor_number);
			printf("value: %8.4f\n",(double)container.value);
			}
		}
	} else if (strncmp(argv[1],"vtol_vehicle_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(vtol_vehicle_status));
		ID = ORB_ID(vtol_vehicle_status);
		struct vtol_vehicle_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vtol_vehicle_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("vtol_in_rw_mode: %s\n",container.vtol_in_rw_mode ? "True" : "False");
			printf("vtol_in_trans_mode: %s\n",container.vtol_in_trans_mode ? "True" : "False");
			printf("vtol_transition_failsafe: %s\n",container.vtol_transition_failsafe ? "True" : "False");
			printf("fw_permanent_stab: %s\n",container.fw_permanent_stab ? "True" : "False");
			printf("airspeed_tot: %8.4f\n",(double)container.airspeed_tot);
			}
		}
	} else if (strncmp(argv[1],"esc_report",50) == 0) {
		sub = orb_subscribe(ORB_ID(esc_report));
		ID = ORB_ID(esc_report);
		struct esc_report_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: esc_report #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("esc_vendor: %u\n",(unsigned)container.esc_vendor);
			printf("esc_errorcount: %u\n",container.esc_errorcount);
			printf("esc_rpm: %d\n",container.esc_rpm);
			printf("esc_voltage: %8.4f\n",(double)container.esc_voltage);
			printf("esc_current: %8.4f\n",(double)container.esc_current);
			printf("esc_temperature: %8.4f\n",(double)container.esc_temperature);
			printf("esc_setpoint: %8.4f\n",(double)container.esc_setpoint);
			printf("esc_setpoint_raw: %u\n",(unsigned)container.esc_setpoint_raw);
			printf("esc_address: %u\n",(unsigned)container.esc_address);
			printf("esc_version: %u\n",(unsigned)container.esc_version);
			printf("esc_state: %u\n",(unsigned)container.esc_state);
			}
		}
	} else if (strncmp(argv[1],"debug_key_value",50) == 0) {
		sub = orb_subscribe(ORB_ID(debug_key_value));
		ID = ORB_ID(debug_key_value);
		struct debug_key_value_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: debug_key_value #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp_ms: %u\n",container.timestamp_ms);
			printf("value: %8.4f\n",(double)container.value);
			}
		}
	} else if (strncmp(argv[1],"wind_estimate",50) == 0) {
		sub = orb_subscribe(ORB_ID(wind_estimate));
		ID = ORB_ID(wind_estimate);
		struct wind_estimate_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: wind_estimate #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("windspeed_north: %8.4f\n",(double)container.windspeed_north);
			printf("windspeed_east: %8.4f\n",(double)container.windspeed_east);
			printf("covariance_north: %8.4f\n",(double)container.covariance_north);
			printf("covariance_east: %8.4f\n",(double)container.covariance_east);
			}
		}
	} else if (strncmp(argv[1],"actuator_controls_1",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_controls_1));
		ID = ORB_ID(actuator_controls_1);
		struct actuator_controls_1_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_controls_1 #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
			printf("control: ");
			for (int j = 0; j < 8; j++) {
				printf("%8.4f ",(double)container.control[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"hil_sensor",50) == 0) {
		sub = orb_subscribe(ORB_ID(hil_sensor));
		ID = ORB_ID(hil_sensor);
		struct hil_sensor_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: hil_sensor #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("gyro_rad_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_rad_s[j]);
			}
			printf("\n");
			printf("gyro_errcount: %u\n",container.gyro_errcount);
			printf("gyro_temp: %8.4f\n",(double)container.gyro_temp);
			printf("accelerometer_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer_mode: %d\n",(int)container.accelerometer_mode);
			printf("accelerometer_range_m_s2: %8.4f\n",(double)container.accelerometer_range_m_s2);
			printf("accelerometer_timestamp: %" PRIu64 "\n",container.accelerometer_timestamp);
			printf("accelerometer_errcount: %u\n",container.accelerometer_errcount);
			printf("accelerometer_temp: %8.4f\n",(double)container.accelerometer_temp);
			printf("magnetometer_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_ga[j]);
			}
			printf("\n");
			printf("magnetometer_mode: %d\n",(int)container.magnetometer_mode);
			printf("magnetometer_range_ga: %8.4f\n",(double)container.magnetometer_range_ga);
			printf("magnetometer_cuttoff_freq_hz: %8.4f\n",(double)container.magnetometer_cuttoff_freq_hz);
			printf("magnetometer_timestamp: %" PRIu64 "\n",container.magnetometer_timestamp);
			printf("magnetometer_errcount: %u\n",container.magnetometer_errcount);
			printf("magnetometer_temp: %8.4f\n",(double)container.magnetometer_temp);
			printf("gyro1_rad_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro1_rad_s[j]);
			}
			printf("\n");
			printf("gyro1_timestamp: %" PRIu64 "\n",container.gyro1_timestamp);
			printf("gyro1_errcount: %u\n",container.gyro1_errcount);
			printf("gyro1_temp: %8.4f\n",(double)container.gyro1_temp);
			printf("accelerometer1_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer1_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer1_timestamp: %" PRIu64 "\n",container.accelerometer1_timestamp);
			printf("accelerometer1_errcount: %u\n",container.accelerometer1_errcount);
			printf("accelerometer1_temp: %8.4f\n",(double)container.accelerometer1_temp);
			printf("magnetometer1_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer1_ga[j]);
			}
			printf("\n");
			printf("magnetometer1_timestamp: %" PRIu64 "\n",container.magnetometer1_timestamp);
			printf("magnetometer1_errcount: %u\n",container.magnetometer1_errcount);
			printf("magnetometer1_temp: %8.4f\n",(double)container.magnetometer1_temp);
			printf("gyro2_rad_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro2_rad_s[j]);
			}
			printf("\n");
			printf("gyro2_timestamp: %" PRIu64 "\n",container.gyro2_timestamp);
			printf("gyro2_errcount: %u\n",container.gyro2_errcount);
			printf("gyro2_temp: %8.4f\n",(double)container.gyro2_temp);
			printf("accelerometer2_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer2_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer2_timestamp: %" PRIu64 "\n",container.accelerometer2_timestamp);
			printf("accelerometer2_errcount: %u\n",container.accelerometer2_errcount);
			printf("accelerometer2_temp: %8.4f\n",(double)container.accelerometer2_temp);
			printf("magnetometer2_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer2_ga[j]);
			}
			printf("\n");
			printf("magnetometer2_timestamp: %" PRIu64 "\n",container.magnetometer2_timestamp);
			printf("magnetometer2_errcount: %u\n",container.magnetometer2_errcount);
			printf("magnetometer2_temp: %8.4f\n",(double)container.magnetometer2_temp);
			printf("baro_pres_mbar: %8.4f\n",(double)container.baro_pres_mbar);
			printf("baro_alt_meter: %8.4f\n",(double)container.baro_alt_meter);
			printf("baro_temp_celcius: %8.4f\n",(double)container.baro_temp_celcius);
			printf("baro_timestamp: %" PRIu64 "\n",container.baro_timestamp);
			printf("baro1_pres_mbar: %8.4f\n",(double)container.baro1_pres_mbar);
			printf("baro1_alt_meter: %8.4f\n",(double)container.baro1_alt_meter);
			printf("baro1_temp_celcius: %8.4f\n",(double)container.baro1_temp_celcius);
			printf("baro1_timestamp: %" PRIu64 "\n",container.baro1_timestamp);
			printf("adc_voltage_v: ");
			for (int j = 0; j < 10; j++) {
				printf("%8.4f ",(double)container.adc_voltage_v[j]);
			}
			printf("\n");
			printf("mcu_temp_celcius: %8.4f\n",(double)container.mcu_temp_celcius);
			printf("differential_pressure_pa: %8.4f\n",(double)container.differential_pressure_pa);
			printf("differential_pressure_timestamp: %" PRIu64 "\n",container.differential_pressure_timestamp);
			printf("differential_pressure_filtered_pa: %8.4f\n",(double)container.differential_pressure_filtered_pa);
			printf("differential_pressure1_pa: %8.4f\n",(double)container.differential_pressure1_pa);
			printf("differential_pressure1_timestamp: %" PRIu64 "\n",container.differential_pressure1_timestamp);
			printf("differential_pressure1_filtered_pa: %8.4f\n",(double)container.differential_pressure1_filtered_pa);
			}
		}
	} else if (strncmp(argv[1],"geofence_result",50) == 0) {
		sub = orb_subscribe(ORB_ID(geofence_result));
		ID = ORB_ID(geofence_result);
		struct geofence_result_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: geofence_result #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("geofence_violated: %s\n",container.geofence_violated ? "True" : "False");
			printf("geofence_action: %u\n",(unsigned)container.geofence_action);
			}
		}
	} else if (strncmp(argv[1],"fence",50) == 0) {
		sub = orb_subscribe(ORB_ID(fence));
		ID = ORB_ID(fence);
		struct fence_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: fence #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("count: %u\n",container.count);
			}
		}
	} else if (strncmp(argv[1],"camera_trigger",50) == 0) {
		sub = orb_subscribe(ORB_ID(camera_trigger));
		ID = ORB_ID(camera_trigger);
		struct camera_trigger_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: camera_trigger #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("seq: %u\n",container.seq);
			}
		}
	} else if (strncmp(argv[1],"uavcan_parameter_request",50) == 0) {
		sub = orb_subscribe(ORB_ID(uavcan_parameter_request));
		ID = ORB_ID(uavcan_parameter_request);
		struct uavcan_parameter_request_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: uavcan_parameter_request #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("message_type: %u\n",(unsigned)container.message_type);
			printf("node_id: %u\n",(unsigned)container.node_id);
			printf("param_index: %d\n",(int)container.param_index);
			printf("param_type: %u\n",(unsigned)container.param_type);
			printf("int_value: %" PRId64 "\n",container.int_value);
			printf("real_value: %8.4f\n",(double)container.real_value);
			}
		}
	} else if (strncmp(argv[1],"mc_virtual_rates_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(mc_virtual_rates_setpoint));
		ID = ORB_ID(mc_virtual_rates_setpoint);
		struct mc_virtual_rates_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: mc_virtual_rates_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll: %8.4f\n",(double)container.roll);
			printf("pitch: %8.4f\n",(double)container.pitch);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("thrust: %8.4f\n",(double)container.thrust);
			}
		}
	} else if (strncmp(argv[1],"sensor_combined",50) == 0) {
		sub = orb_subscribe(ORB_ID(sensor_combined));
		ID = ORB_ID(sensor_combined);
		struct sensor_combined_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: sensor_combined #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("gyro_timestamp: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.gyro_timestamp[j]);
			}
			printf("\n");
			printf("gyro_rad_s: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.gyro_rad_s[j]);
			}
			printf("\n");
			printf("gyro_integral_rad: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.gyro_integral_rad[j]);
			}
			printf("\n");
			printf("gyro_integral_dt: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.gyro_integral_dt[j]);
			}
			printf("\n");
			printf("gyro_temp: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_temp[j]);
			}
			printf("\n");
			printf("accelerometer_m_s2: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.accelerometer_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer_integral_m_s: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.accelerometer_integral_m_s[j]);
			}
			printf("\n");
			printf("accelerometer_integral_dt: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.accelerometer_integral_dt[j]);
			}
			printf("\n");
			printf("accelerometer_range_m_s2: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer_range_m_s2[j]);
			}
			printf("\n");
			printf("accelerometer_timestamp: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.accelerometer_timestamp[j]);
			}
			printf("\n");
			printf("accelerometer_temp: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer_temp[j]);
			}
			printf("\n");
			printf("magnetometer_ga: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.magnetometer_ga[j]);
			}
			printf("\n");
			printf("magnetometer_range_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_range_ga[j]);
			}
			printf("\n");
			printf("magnetometer_cuttoff_freq_hz: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_cuttoff_freq_hz[j]);
			}
			printf("\n");
			printf("magnetometer_timestamp: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.magnetometer_timestamp[j]);
			}
			printf("\n");
			printf("magnetometer_temp: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_temp[j]);
			}
			printf("\n");
			printf("baro_pres_mbar: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.baro_pres_mbar[j]);
			}
			printf("\n");
			printf("baro_alt_meter: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.baro_alt_meter[j]);
			}
			printf("\n");
			printf("baro_temp_celcius: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.baro_temp_celcius[j]);
			}
			printf("\n");
			printf("baro_timestamp: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.baro_timestamp[j]);
			}
			printf("\n");
			printf("adc_voltage_v: ");
			for (int j = 0; j < 10; j++) {
				printf("%8.4f ",(double)container.adc_voltage_v[j]);
			}
			printf("\n");
			printf("mcu_temp_celcius: %8.4f\n",(double)container.mcu_temp_celcius);
			printf("differential_pressure_pa: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.differential_pressure_pa[j]);
			}
			printf("\n");
			printf("differential_pressure_timestamp: ");
			for (int j = 0; j < 3; j++) {
				printf("%" PRIu64 "",container.differential_pressure_timestamp[j]);
			}
			printf("\n");
			printf("differential_pressure_filtered_pa: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.differential_pressure_filtered_pa[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"actuator_controls_2",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_controls_2));
		ID = ORB_ID(actuator_controls_2);
		struct actuator_controls_2_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_controls_2 #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
			printf("control: ");
			for (int j = 0; j < 8; j++) {
				printf("%8.4f ",(double)container.control[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"output_pwm",50) == 0) {
		sub = orb_subscribe(ORB_ID(output_pwm));
		ID = ORB_ID(output_pwm);
		struct output_pwm_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: output_pwm #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("channel_count: %u\n",container.channel_count);
			}
		}
	} else if (strncmp(argv[1],"ekf2_replay",50) == 0) {
		sub = orb_subscribe(ORB_ID(ekf2_replay));
		ID = ORB_ID(ekf2_replay);
		struct ekf2_replay_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: ekf2_replay #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("time_ref: %" PRIu64 "\n",container.time_ref);
			printf("gyro_integral_dt: %" PRIu64 "\n",container.gyro_integral_dt);
			printf("accelerometer_integral_dt: %" PRIu64 "\n",container.accelerometer_integral_dt);
			printf("magnetometer_timestamp: %" PRIu64 "\n",container.magnetometer_timestamp);
			printf("baro_timestamp: %" PRIu64 "\n",container.baro_timestamp);
			printf("gyro_integral_rad: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.gyro_integral_rad[j]);
			}
			printf("\n");
			printf("accelerometer_integral_m_s: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.accelerometer_integral_m_s[j]);
			}
			printf("\n");
			printf("magnetometer_ga: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.magnetometer_ga[j]);
			}
			printf("\n");
			printf("baro_alt_meter: %8.4f\n",(double)container.baro_alt_meter);
			printf("time_usec: %" PRIu64 "\n",container.time_usec);
			printf("time_usec_vel: %" PRIu64 "\n",container.time_usec_vel);
			printf("lat: %d\n",container.lat);
			printf("lon: %d\n",container.lon);
			printf("alt: %d\n",container.alt);
			printf("fix_type: %u\n",(unsigned)container.fix_type);
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			printf("vel_m_s: %8.4f\n",(double)container.vel_m_s);
			printf("vel_n_m_s: %8.4f\n",(double)container.vel_n_m_s);
			printf("vel_e_m_s: %8.4f\n",(double)container.vel_e_m_s);
			printf("vel_d_m_s: %8.4f\n",(double)container.vel_d_m_s);
			printf("vel_ned_valid: %s\n",container.vel_ned_valid ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"sensor_accel",50) == 0) {
		sub = orb_subscribe(ORB_ID(sensor_accel));
		ID = ORB_ID(sensor_accel);
		struct sensor_accel_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: sensor_accel #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("integral_dt: %" PRIu64 "\n",container.integral_dt);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("x_integral: %8.4f\n",(double)container.x_integral);
			printf("y_integral: %8.4f\n",(double)container.y_integral);
			printf("z_integral: %8.4f\n",(double)container.z_integral);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("range_m_s2: %8.4f\n",(double)container.range_m_s2);
			printf("scaling: %8.4f\n",(double)container.scaling);
			printf("x_raw: %d\n",(int)container.x_raw);
			printf("y_raw: %d\n",(int)container.y_raw);
			printf("z_raw: %d\n",(int)container.z_raw);
			printf("temperature_raw: %d\n",(int)container.temperature_raw);
			}
		}
	} else if (strncmp(argv[1],"telemetry_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(telemetry_status));
		ID = ORB_ID(telemetry_status);
		struct telemetry_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: telemetry_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("heartbeat_time: %" PRIu64 "\n",container.heartbeat_time);
			printf("telem_time: %" PRIu64 "\n",container.telem_time);
			printf("type: %u\n",(unsigned)container.type);
			printf("rssi: %u\n",(unsigned)container.rssi);
			printf("remote_rssi: %u\n",(unsigned)container.remote_rssi);
			printf("rxerrors: %u\n",(unsigned)container.rxerrors);
			printf("fixed: %u\n",(unsigned)container.fixed);
			printf("noise: %u\n",(unsigned)container.noise);
			printf("remote_noise: %u\n",(unsigned)container.remote_noise);
			printf("txbuf: %u\n",(unsigned)container.txbuf);
			printf("system_id: %u\n",(unsigned)container.system_id);
			printf("component_id: %u\n",(unsigned)container.component_id);
			}
		}
	} else if (strncmp(argv[1],"actuator_controls_virtual_fw",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_controls_virtual_fw));
		ID = ORB_ID(actuator_controls_virtual_fw);
		struct actuator_controls_virtual_fw_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_controls_virtual_fw #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
			printf("control: ");
			for (int j = 0; j < 8; j++) {
				printf("%8.4f ",(double)container.control[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"mc_virtual_attitude_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(mc_virtual_attitude_setpoint));
		ID = ORB_ID(mc_virtual_attitude_setpoint);
		struct mc_virtual_attitude_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: mc_virtual_attitude_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll_body: %8.4f\n",(double)container.roll_body);
			printf("pitch_body: %8.4f\n",(double)container.pitch_body);
			printf("yaw_body: %8.4f\n",(double)container.yaw_body);
			printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
			printf("R_body: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.R_body[j]);
			}
			printf("\n");
			printf("R_valid: %s\n",container.R_valid ? "True" : "False");
			printf("q_d: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_d[j]);
			}
			printf("\n");
			printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
			printf("q_e: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_e[j]);
			}
			printf("\n");
			printf("q_e_valid: %s\n",container.q_e_valid ? "True" : "False");
			printf("thrust: %8.4f\n",(double)container.thrust);
			printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
			printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
			printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
			printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
			printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
			printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"fence_vertex",50) == 0) {
		sub = orb_subscribe(ORB_ID(fence_vertex));
		ID = ORB_ID(fence_vertex);
		struct fence_vertex_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: fence_vertex #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			}
		}
	} else if (strncmp(argv[1],"mission_result",50) == 0) {
		sub = orb_subscribe(ORB_ID(mission_result));
		ID = ORB_ID(mission_result);
		struct mission_result_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: mission_result #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("instance_count: %u\n",container.instance_count);
			printf("seq_reached: %u\n",container.seq_reached);
			printf("seq_current: %u\n",container.seq_current);
			printf("valid: %s\n",container.valid ? "True" : "False");
			printf("warning: %s\n",container.warning ? "True" : "False");
			printf("reached: %s\n",container.reached ? "True" : "False");
			printf("finished: %s\n",container.finished ? "True" : "False");
			printf("stay_in_failsafe: %s\n",container.stay_in_failsafe ? "True" : "False");
			printf("flight_termination: %s\n",container.flight_termination ? "True" : "False");
			printf("item_do_jump_changed: %s\n",container.item_do_jump_changed ? "True" : "False");
			printf("item_changed_index: %u\n",container.item_changed_index);
			printf("item_do_jump_remaining: %u\n",container.item_do_jump_remaining);
			printf("mission_failure: %s\n",container.mission_failure ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"fw_virtual_rates_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(fw_virtual_rates_setpoint));
		ID = ORB_ID(fw_virtual_rates_setpoint);
		struct fw_virtual_rates_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: fw_virtual_rates_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll: %8.4f\n",(double)container.roll);
			printf("pitch: %8.4f\n",(double)container.pitch);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("thrust: %8.4f\n",(double)container.thrust);
			}
		}
	} else if (strncmp(argv[1],"system_power",50) == 0) {
		sub = orb_subscribe(ORB_ID(system_power));
		ID = ORB_ID(system_power);
		struct system_power_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: system_power #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("voltage5V_v: %8.4f\n",(double)container.voltage5V_v);
			printf("usb_connected: %u\n",(unsigned)container.usb_connected);
			printf("brick_valid: %u\n",(unsigned)container.brick_valid);
			printf("servo_valid: %u\n",(unsigned)container.servo_valid);
			printf("periph_5V_OC: %u\n",(unsigned)container.periph_5V_OC);
			printf("hipower_5V_OC: %u\n",(unsigned)container.hipower_5V_OC);
			}
		}
	} else if (strncmp(argv[1],"vehicle_local_position",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_local_position));
		ID = ORB_ID(vehicle_local_position);
		struct vehicle_local_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_local_position #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("xy_valid: %s\n",container.xy_valid ? "True" : "False");
			printf("z_valid: %s\n",container.z_valid ? "True" : "False");
			printf("v_xy_valid: %s\n",container.v_xy_valid ? "True" : "False");
			printf("v_z_valid: %s\n",container.v_z_valid ? "True" : "False");
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vy: %8.4f\n",(double)container.vy);
			printf("vz: %8.4f\n",(double)container.vz);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("xy_global: %s\n",container.xy_global ? "True" : "False");
			printf("z_global: %s\n",container.z_global ? "True" : "False");
			printf("ref_timestamp: %" PRIu64 "\n",container.ref_timestamp);
			printf("ref_lat: %8.4f\n",(double)container.ref_lat);
			printf("ref_lon: %8.4f\n",(double)container.ref_lon);
			printf("ref_alt: %8.4f\n",(double)container.ref_alt);
			printf("dist_bottom: %8.4f\n",(double)container.dist_bottom);
			printf("dist_bottom_rate: %8.4f\n",(double)container.dist_bottom_rate);
			printf("surface_bottom_timestamp: %" PRIu64 "\n",container.surface_bottom_timestamp);
			printf("dist_bottom_valid: %s\n",container.dist_bottom_valid ? "True" : "False");
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			}
		}
	} else if (strncmp(argv[1],"att_pos_mocap",50) == 0) {
		sub = orb_subscribe(ORB_ID(att_pos_mocap));
		ID = ORB_ID(att_pos_mocap);
		struct att_pos_mocap_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: att_pos_mocap #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("id: %u\n",container.id);
			printf("timestamp_boot: %" PRIu64 "\n",container.timestamp_boot);
			printf("timestamp_computer: %" PRIu64 "\n",container.timestamp_computer);
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			}
		}
	} else if (strncmp(argv[1],"tecs_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(tecs_status));
		ID = ORB_ID(tecs_status);
		struct tecs_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: tecs_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("altitudeSp: %8.4f\n",(double)container.altitudeSp);
			printf("altitude_filtered: %8.4f\n",(double)container.altitude_filtered);
			printf("flightPathAngleSp: %8.4f\n",(double)container.flightPathAngleSp);
			printf("flightPathAngle: %8.4f\n",(double)container.flightPathAngle);
			printf("flightPathAngleFiltered: %8.4f\n",(double)container.flightPathAngleFiltered);
			printf("airspeedSp: %8.4f\n",(double)container.airspeedSp);
			printf("airspeed_filtered: %8.4f\n",(double)container.airspeed_filtered);
			printf("airspeedDerivativeSp: %8.4f\n",(double)container.airspeedDerivativeSp);
			printf("airspeedDerivative: %8.4f\n",(double)container.airspeedDerivative);
			printf("totalEnergyError: %8.4f\n",(double)container.totalEnergyError);
			printf("energyDistributionError: %8.4f\n",(double)container.energyDistributionError);
			printf("totalEnergyRateError: %8.4f\n",(double)container.totalEnergyRateError);
			printf("energyDistributionRateError: %8.4f\n",(double)container.energyDistributionRateError);
			printf("throttle_integ: %8.4f\n",(double)container.throttle_integ);
			printf("pitch_integ: %8.4f\n",(double)container.pitch_integ);
			printf("mode: %u\n",(unsigned)container.mode);
			}
		}
	} else if (strncmp(argv[1],"vehicle_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_status));
		ID = ORB_ID(vehicle_status);
		struct vehicle_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("counter: %u\n",(unsigned)container.counter);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("main_state: %u\n",(unsigned)container.main_state);
			printf("main_state_prev: %u\n",(unsigned)container.main_state_prev);
			printf("nav_state: %u\n",(unsigned)container.nav_state);
			printf("arming_state: %u\n",(unsigned)container.arming_state);
			printf("hil_state: %u\n",(unsigned)container.hil_state);
			printf("failsafe: %s\n",container.failsafe ? "True" : "False");
			printf("calibration_enabled: %s\n",container.calibration_enabled ? "True" : "False");
			printf("system_type: %d\n",container.system_type);
			printf("system_id: %u\n",container.system_id);
			printf("component_id: %u\n",container.component_id);
			printf("is_rotary_wing: %s\n",container.is_rotary_wing ? "True" : "False");
			printf("is_vtol: %s\n",container.is_vtol ? "True" : "False");
			printf("vtol_fw_permanent_stab: %s\n",container.vtol_fw_permanent_stab ? "True" : "False");
			printf("in_transition_mode: %s\n",container.in_transition_mode ? "True" : "False");
			printf("condition_battery_voltage_valid: %s\n",container.condition_battery_voltage_valid ? "True" : "False");
			printf("condition_system_in_air_restore: %s\n",container.condition_system_in_air_restore ? "True" : "False");
			printf("condition_system_sensors_initialized: %s\n",container.condition_system_sensors_initialized ? "True" : "False");
			printf("condition_system_prearm_error_reported: %s\n",container.condition_system_prearm_error_reported ? "True" : "False");
			printf("condition_system_hotplug_timeout: %s\n",container.condition_system_hotplug_timeout ? "True" : "False");
			printf("condition_system_returned_to_home: %s\n",container.condition_system_returned_to_home ? "True" : "False");
			printf("condition_auto_mission_available: %s\n",container.condition_auto_mission_available ? "True" : "False");
			printf("condition_global_position_valid: %s\n",container.condition_global_position_valid ? "True" : "False");
			printf("condition_home_position_valid: %s\n",container.condition_home_position_valid ? "True" : "False");
			printf("condition_local_position_valid: %s\n",container.condition_local_position_valid ? "True" : "False");
			printf("condition_local_altitude_valid: %s\n",container.condition_local_altitude_valid ? "True" : "False");
			printf("condition_airspeed_valid: %s\n",container.condition_airspeed_valid ? "True" : "False");
			printf("condition_landed: %s\n",container.condition_landed ? "True" : "False");
			printf("condition_power_input_valid: %s\n",container.condition_power_input_valid ? "True" : "False");
			printf("avionics_power_rail_voltage: %8.4f\n",(double)container.avionics_power_rail_voltage);
			printf("usb_connected: %s\n",container.usb_connected ? "True" : "False");
			printf("rc_signal_found_once: %s\n",container.rc_signal_found_once ? "True" : "False");
			printf("rc_signal_lost: %s\n",container.rc_signal_lost ? "True" : "False");
			printf("rc_signal_lost_timestamp: %" PRIu64 "\n",container.rc_signal_lost_timestamp);
			printf("rc_signal_lost_cmd: %s\n",container.rc_signal_lost_cmd ? "True" : "False");
			printf("rc_input_blocked: %s\n",container.rc_input_blocked ? "True" : "False");
			printf("rc_input_mode: %u\n",(unsigned)container.rc_input_mode);
			printf("data_link_lost: %s\n",container.data_link_lost ? "True" : "False");
			printf("data_link_lost_cmd: %s\n",container.data_link_lost_cmd ? "True" : "False");
			printf("data_link_lost_counter: %u\n",(unsigned)container.data_link_lost_counter);
			printf("engine_failure: %s\n",container.engine_failure ? "True" : "False");
			printf("engine_failure_cmd: %s\n",container.engine_failure_cmd ? "True" : "False");
			printf("vtol_transition_failure: %s\n",container.vtol_transition_failure ? "True" : "False");
			printf("vtol_transition_failure_cmd: %s\n",container.vtol_transition_failure_cmd ? "True" : "False");
			printf("gps_failure: %s\n",container.gps_failure ? "True" : "False");
			printf("gps_failure_cmd: %s\n",container.gps_failure_cmd ? "True" : "False");
			printf("mission_failure: %s\n",container.mission_failure ? "True" : "False");
			printf("barometer_failure: %s\n",container.barometer_failure ? "True" : "False");
			printf("offboard_control_signal_found_once: %s\n",container.offboard_control_signal_found_once ? "True" : "False");
			printf("offboard_control_signal_lost: %s\n",container.offboard_control_signal_lost ? "True" : "False");
			printf("offboard_control_signal_weak: %s\n",container.offboard_control_signal_weak ? "True" : "False");
			printf("offboard_control_signal_lost_interval: %" PRIu64 "\n",container.offboard_control_signal_lost_interval);
			printf("offboard_control_set_by_command: %s\n",container.offboard_control_set_by_command ? "True" : "False");
			printf("onboard_control_sensors_present: %u\n",container.onboard_control_sensors_present);
			printf("onboard_control_sensors_enabled: %u\n",container.onboard_control_sensors_enabled);
			printf("onboard_control_sensors_health: %u\n",container.onboard_control_sensors_health);
			printf("load: %8.4f\n",(double)container.load);
			printf("battery_voltage: %8.4f\n",(double)container.battery_voltage);
			printf("battery_current: %8.4f\n",(double)container.battery_current);
			printf("battery_remaining: %8.4f\n",(double)container.battery_remaining);
			printf("battery_discharged_mah: %8.4f\n",(double)container.battery_discharged_mah);
			printf("battery_cell_count: %u\n",container.battery_cell_count);
			printf("battery_warning: %u\n",(unsigned)container.battery_warning);
			printf("drop_rate_comm: %u\n",(unsigned)container.drop_rate_comm);
			printf("errors_comm: %u\n",(unsigned)container.errors_comm);
			printf("errors_count1: %u\n",(unsigned)container.errors_count1);
			printf("errors_count2: %u\n",(unsigned)container.errors_count2);
			printf("errors_count3: %u\n",(unsigned)container.errors_count3);
			printf("errors_count4: %u\n",(unsigned)container.errors_count4);
			printf("circuit_breaker_engaged_power_check: %s\n",container.circuit_breaker_engaged_power_check ? "True" : "False");
			printf("circuit_breaker_engaged_airspd_check: %s\n",container.circuit_breaker_engaged_airspd_check ? "True" : "False");
			printf("circuit_breaker_engaged_enginefailure_check: %s\n",container.circuit_breaker_engaged_enginefailure_check ? "True" : "False");
			printf("circuit_breaker_engaged_gpsfailure_check: %s\n",container.circuit_breaker_engaged_gpsfailure_check ? "True" : "False");
			printf("cb_usb: %s\n",container.cb_usb ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"input_rc",50) == 0) {
		sub = orb_subscribe(ORB_ID(input_rc));
		ID = ORB_ID(input_rc);
		struct input_rc_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: input_rc #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp_publication: %" PRIu64 "\n",container.timestamp_publication);
			printf("timestamp_last_signal: %" PRIu64 "\n",container.timestamp_last_signal);
			printf("channel_count: %u\n",container.channel_count);
			printf("rssi: %d\n",container.rssi);
			printf("rc_failsafe: %s\n",container.rc_failsafe ? "True" : "False");
			printf("rc_lost: %s\n",container.rc_lost ? "True" : "False");
			printf("rc_lost_frame_count: %u\n",(unsigned)container.rc_lost_frame_count);
			printf("rc_total_frame_count: %u\n",(unsigned)container.rc_total_frame_count);
			printf("rc_ppm_frame_length: %u\n",(unsigned)container.rc_ppm_frame_length);
			printf("input_source: %u\n",(unsigned)container.input_source);
			}
		}
	} else if (strncmp(argv[1],"vehicle_attitude",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_attitude));
		ID = ORB_ID(vehicle_attitude);
		struct vehicle_attitude_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_attitude #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll: %8.4f\n",(double)container.roll);
			printf("pitch: %8.4f\n",(double)container.pitch);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("rollspeed: %8.4f\n",(double)container.rollspeed);
			printf("pitchspeed: %8.4f\n",(double)container.pitchspeed);
			printf("yawspeed: %8.4f\n",(double)container.yawspeed);
			printf("rollacc: %8.4f\n",(double)container.rollacc);
			printf("pitchacc: %8.4f\n",(double)container.pitchacc);
			printf("yawacc: %8.4f\n",(double)container.yawacc);
			printf("rate_vibration: %8.4f\n",(double)container.rate_vibration);
			printf("accel_vibration: %8.4f\n",(double)container.accel_vibration);
			printf("mag_vibration: %8.4f\n",(double)container.mag_vibration);
			printf("rate_offsets: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.rate_offsets[j]);
			}
			printf("\n");
			printf("R: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.R[j]);
			}
			printf("\n");
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			printf("g_comp: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.g_comp[j]);
			}
			printf("\n");
			printf("R_valid: %s\n",container.R_valid ? "True" : "False");
			printf("q_valid: %s\n",container.q_valid ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"safety",50) == 0) {
		sub = orb_subscribe(ORB_ID(safety));
		ID = ORB_ID(safety);
		struct safety_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: safety #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("safety_switch_available: %s\n",container.safety_switch_available ? "True" : "False");
			printf("safety_off: %s\n",container.safety_off ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"vehicle_rates_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_rates_setpoint));
		ID = ORB_ID(vehicle_rates_setpoint);
		struct vehicle_rates_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_rates_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll: %8.4f\n",(double)container.roll);
			printf("pitch: %8.4f\n",(double)container.pitch);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("thrust: %8.4f\n",(double)container.thrust);
			}
		}
	} else if (strncmp(argv[1],"estimator_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(estimator_status));
		ID = ORB_ID(estimator_status);
		struct estimator_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: estimator_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("states: ");
			for (int j = 0; j < 32; j++) {
				printf("%8.4f ",(double)container.states[j]);
			}
			printf("\n");
			printf("n_states: %8.4f\n",(double)container.n_states);
			printf("vibe: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.vibe[j]);
			}
			printf("\n");
			printf("nan_flags: %u\n",(unsigned)container.nan_flags);
			printf("health_flags: %u\n",(unsigned)container.health_flags);
			printf("timeout_flags: %u\n",(unsigned)container.timeout_flags);
			printf("covariances: ");
			for (int j = 0; j < 28; j++) {
				printf("%8.4f ",(double)container.covariances[j]);
			}
			printf("\n");
			printf("gps_check_fail_flags: %u\n",(unsigned)container.gps_check_fail_flags);
			}
		}
	} else if (strncmp(argv[1],"vehicle_global_velocity_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_global_velocity_setpoint));
		ID = ORB_ID(vehicle_global_velocity_setpoint);
		struct vehicle_global_velocity_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_global_velocity_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vy: %8.4f\n",(double)container.vy);
			printf("vz: %8.4f\n",(double)container.vz);
			}
		}
	} else if (strncmp(argv[1],"vehicle_land_detected",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_land_detected));
		ID = ORB_ID(vehicle_land_detected);
		struct vehicle_land_detected_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_land_detected #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("landed: %s\n",container.landed ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"parameter_update",50) == 0) {
		sub = orb_subscribe(ORB_ID(parameter_update));
		ID = ORB_ID(parameter_update);
		struct parameter_update_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: parameter_update #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("saved: %s\n",container.saved ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"actuator_controls_0",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_controls_0));
		ID = ORB_ID(actuator_controls_0);
		struct actuator_controls_0_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_controls_0 #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
			printf("control: ");
			for (int j = 0; j < 8; j++) {
				printf("%8.4f ",(double)container.control[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"satellite_info",50) == 0) {
		sub = orb_subscribe(ORB_ID(satellite_info));
		ID = ORB_ID(satellite_info);
		struct satellite_info_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: satellite_info #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("count: %u\n",(unsigned)container.count);
			}
		}
	} else if (strncmp(argv[1],"vehicle_attitude_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_attitude_setpoint));
		ID = ORB_ID(vehicle_attitude_setpoint);
		struct vehicle_attitude_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_attitude_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll_body: %8.4f\n",(double)container.roll_body);
			printf("pitch_body: %8.4f\n",(double)container.pitch_body);
			printf("yaw_body: %8.4f\n",(double)container.yaw_body);
			printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
			printf("R_body: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.R_body[j]);
			}
			printf("\n");
			printf("R_valid: %s\n",container.R_valid ? "True" : "False");
			printf("q_d: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_d[j]);
			}
			printf("\n");
			printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
			printf("q_e: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_e[j]);
			}
			printf("\n");
			printf("q_e_valid: %s\n",container.q_e_valid ? "True" : "False");
			printf("thrust: %8.4f\n",(double)container.thrust);
			printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
			printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
			printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
			printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
			printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
			printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"esc_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(esc_status));
		ID = ORB_ID(esc_status);
		struct esc_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: esc_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("counter: %u\n",(unsigned)container.counter);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("esc_count: %u\n",(unsigned)container.esc_count);
			printf("esc_connectiontype: %u\n",(unsigned)container.esc_connectiontype);
			}
		}
	} else if (strncmp(argv[1],"mission",50) == 0) {
		sub = orb_subscribe(ORB_ID(mission));
		ID = ORB_ID(mission);
		struct mission_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: mission #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("dataman_id: %d\n",container.dataman_id);
			printf("count: %u\n",container.count);
			printf("current_seq: %d\n",container.current_seq);
			}
		}
	} else if (strncmp(argv[1],"optical_flow",50) == 0) {
		sub = orb_subscribe(ORB_ID(optical_flow));
		ID = ORB_ID(optical_flow);
		struct optical_flow_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: optical_flow #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("sensor_id: %u\n",(unsigned)container.sensor_id);
			printf("pixel_flow_x_integral: %8.4f\n",(double)container.pixel_flow_x_integral);
			printf("pixel_flow_y_integral: %8.4f\n",(double)container.pixel_flow_y_integral);
			printf("gyro_x_rate_integral: %8.4f\n",(double)container.gyro_x_rate_integral);
			printf("gyro_y_rate_integral: %8.4f\n",(double)container.gyro_y_rate_integral);
			printf("gyro_z_rate_integral: %8.4f\n",(double)container.gyro_z_rate_integral);
			printf("ground_distance_m: %8.4f\n",(double)container.ground_distance_m);
			printf("integration_timespan: %u\n",container.integration_timespan);
			printf("time_since_last_sonar_update: %u\n",container.time_since_last_sonar_update);
			printf("frame_count_since_last_readout: %u\n",(unsigned)container.frame_count_since_last_readout);
			printf("gyro_temperature: %d\n",(int)container.gyro_temperature);
			printf("quality: %u\n",(unsigned)container.quality);
			}
		}
	} else if (strncmp(argv[1],"vision_position_estimate",50) == 0) {
		sub = orb_subscribe(ORB_ID(vision_position_estimate));
		ID = ORB_ID(vision_position_estimate);
		struct vision_position_estimate_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vision_position_estimate #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("id: %u\n",container.id);
			printf("timestamp_boot: %" PRIu64 "\n",container.timestamp_boot);
			printf("timestamp_computer: %" PRIu64 "\n",container.timestamp_computer);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vy: %8.4f\n",(double)container.vy);
			printf("vz: %8.4f\n",(double)container.vz);
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"battery_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(battery_status));
		ID = ORB_ID(battery_status);
		struct battery_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: battery_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("voltage_v: %8.4f\n",(double)container.voltage_v);
			printf("voltage_filtered_v: %8.4f\n",(double)container.voltage_filtered_v);
			printf("current_a: %8.4f\n",(double)container.current_a);
			printf("discharged_mah: %8.4f\n",(double)container.discharged_mah);
			printf("is_powering_off: %s\n",container.is_powering_off ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"vehicle_command_ack",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_command_ack));
		ID = ORB_ID(vehicle_command_ack);
		struct vehicle_command_ack_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_command_ack #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("command: %u\n",(unsigned)container.command);
			printf("result: %u\n",(unsigned)container.result);
			}
		}
	} else if (strncmp(argv[1],"actuator_controls_virtual_mc",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_controls_virtual_mc));
		ID = ORB_ID(actuator_controls_virtual_mc);
		struct actuator_controls_virtual_mc_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_controls_virtual_mc #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
			printf("control: ");
			for (int j = 0; j < 8; j++) {
				printf("%8.4f ",(double)container.control[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"uavcan_parameter_value",50) == 0) {
		sub = orb_subscribe(ORB_ID(uavcan_parameter_value));
		ID = ORB_ID(uavcan_parameter_value);
		struct uavcan_parameter_value_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: uavcan_parameter_value #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("node_id: %u\n",(unsigned)container.node_id);
			printf("param_index: %d\n",(int)container.param_index);
			printf("param_count: %u\n",(unsigned)container.param_count);
			printf("param_type: %u\n",(unsigned)container.param_type);
			printf("int_value: %" PRId64 "\n",container.int_value);
			printf("real_value: %8.4f\n",(double)container.real_value);
			}
		}
	} else if (strncmp(argv[1],"ekf2_innovations",50) == 0) {
		sub = orb_subscribe(ORB_ID(ekf2_innovations));
		ID = ORB_ID(ekf2_innovations);
		struct ekf2_innovations_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: ekf2_innovations #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("vel_pos_innov: ");
			for (int j = 0; j < 6; j++) {
				printf("%8.4f ",(double)container.vel_pos_innov[j]);
			}
			printf("\n");
			printf("mag_innov: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.mag_innov[j]);
			}
			printf("\n");
			printf("heading_innov: %8.4f\n",(double)container.heading_innov);
			printf("vel_pos_innov_var: ");
			for (int j = 0; j < 6; j++) {
				printf("%8.4f ",(double)container.vel_pos_innov_var[j]);
			}
			printf("\n");
			printf("mag_innov_var: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.mag_innov_var[j]);
			}
			printf("\n");
			printf("heading_innov_var: %8.4f\n",(double)container.heading_innov_var);
			}
		}
	} else if (strncmp(argv[1],"filtered_bottom_flow",50) == 0) {
		sub = orb_subscribe(ORB_ID(filtered_bottom_flow));
		ID = ORB_ID(filtered_bottom_flow);
		struct filtered_bottom_flow_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: filtered_bottom_flow #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("sumx: %8.4f\n",(double)container.sumx);
			printf("sumy: %8.4f\n",(double)container.sumy);
			printf("vx: %8.4f\n",(double)container.vx);
			printf("vy: %8.4f\n",(double)container.vy);
			}
		}
	} else if (strncmp(argv[1],"encoders",50) == 0) {
		sub = orb_subscribe(ORB_ID(encoders));
		ID = ORB_ID(encoders);
		struct encoders_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: encoders #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("velocity: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.velocity[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"control_state",50) == 0) {
		sub = orb_subscribe(ORB_ID(control_state));
		ID = ORB_ID(control_state);
		struct control_state_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: control_state #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("x_acc: %8.4f\n",(double)container.x_acc);
			printf("y_acc: %8.4f\n",(double)container.y_acc);
			printf("z_acc: %8.4f\n",(double)container.z_acc);
			printf("x_vel: %8.4f\n",(double)container.x_vel);
			printf("y_vel: %8.4f\n",(double)container.y_vel);
			printf("z_vel: %8.4f\n",(double)container.z_vel);
			printf("x_pos: %8.4f\n",(double)container.x_pos);
			printf("y_pos: %8.4f\n",(double)container.y_pos);
			printf("z_pos: %8.4f\n",(double)container.z_pos);
			printf("airspeed: %8.4f\n",(double)container.airspeed);
			printf("airspeed_valid: %s\n",container.airspeed_valid ? "True" : "False");
			printf("vel_variance: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.vel_variance[j]);
			}
			printf("\n");
			printf("pos_variance: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.pos_variance[j]);
			}
			printf("\n");
			printf("q: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q[j]);
			}
			printf("\n");
			printf("roll_rate: %8.4f\n",(double)container.roll_rate);
			printf("pitch_rate: %8.4f\n",(double)container.pitch_rate);
			printf("yaw_rate: %8.4f\n",(double)container.yaw_rate);
			printf("horz_acc_mag: %8.4f\n",(double)container.horz_acc_mag);
			}
		}
	} else if (strncmp(argv[1],"time_offset",50) == 0) {
		sub = orb_subscribe(ORB_ID(time_offset));
		ID = ORB_ID(time_offset);
		struct time_offset_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: time_offset #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("offset_ns: %" PRIu64 "\n",container.offset_ns);
			}
		}
	} else if (strncmp(argv[1],"manual_control_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(manual_control_setpoint));
		ID = ORB_ID(manual_control_setpoint);
		struct manual_control_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: manual_control_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("r: %8.4f\n",(double)container.r);
			printf("flaps: %8.4f\n",(double)container.flaps);
			printf("aux1: %8.4f\n",(double)container.aux1);
			printf("aux2: %8.4f\n",(double)container.aux2);
			printf("aux3: %8.4f\n",(double)container.aux3);
			printf("aux4: %8.4f\n",(double)container.aux4);
			printf("aux5: %8.4f\n",(double)container.aux5);
			printf("mode_switch: %u\n",(unsigned)container.mode_switch);
			printf("return_switch: %u\n",(unsigned)container.return_switch);
			printf("rattitude_switch: %u\n",(unsigned)container.rattitude_switch);
			printf("posctl_switch: %u\n",(unsigned)container.posctl_switch);
			printf("loiter_switch: %u\n",(unsigned)container.loiter_switch);
			printf("acro_switch: %u\n",(unsigned)container.acro_switch);
			printf("offboard_switch: %u\n",(unsigned)container.offboard_switch);
			printf("kill_switch: %u\n",(unsigned)container.kill_switch);
			}
		}
	} else if (strncmp(argv[1],"servorail_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(servorail_status));
		ID = ORB_ID(servorail_status);
		struct servorail_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: servorail_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("voltage_v: %8.4f\n",(double)container.voltage_v);
			printf("rssi_v: %8.4f\n",(double)container.rssi_v);
			}
		}
	} else if (strncmp(argv[1],"fw_virtual_attitude_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(fw_virtual_attitude_setpoint));
		ID = ORB_ID(fw_virtual_attitude_setpoint);
		struct fw_virtual_attitude_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: fw_virtual_attitude_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll_body: %8.4f\n",(double)container.roll_body);
			printf("pitch_body: %8.4f\n",(double)container.pitch_body);
			printf("yaw_body: %8.4f\n",(double)container.yaw_body);
			printf("yaw_sp_move_rate: %8.4f\n",(double)container.yaw_sp_move_rate);
			printf("R_body: ");
			for (int j = 0; j < 9; j++) {
				printf("%8.4f ",(double)container.R_body[j]);
			}
			printf("\n");
			printf("R_valid: %s\n",container.R_valid ? "True" : "False");
			printf("q_d: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_d[j]);
			}
			printf("\n");
			printf("q_d_valid: %s\n",container.q_d_valid ? "True" : "False");
			printf("q_e: ");
			for (int j = 0; j < 4; j++) {
				printf("%8.4f ",(double)container.q_e[j]);
			}
			printf("\n");
			printf("q_e_valid: %s\n",container.q_e_valid ? "True" : "False");
			printf("thrust: %8.4f\n",(double)container.thrust);
			printf("roll_reset_integral: %s\n",container.roll_reset_integral ? "True" : "False");
			printf("pitch_reset_integral: %s\n",container.pitch_reset_integral ? "True" : "False");
			printf("yaw_reset_integral: %s\n",container.yaw_reset_integral ? "True" : "False");
			printf("fw_control_yaw: %s\n",container.fw_control_yaw ? "True" : "False");
			printf("disable_mc_yaw_control: %s\n",container.disable_mc_yaw_control ? "True" : "False");
			printf("apply_flaps: %s\n",container.apply_flaps ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"rc_parameter_map",50) == 0) {
		sub = orb_subscribe(ORB_ID(rc_parameter_map));
		ID = ORB_ID(rc_parameter_map);
		struct rc_parameter_map_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: rc_parameter_map #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("scale: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.scale[j]);
			}
			printf("\n");
			printf("value0: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.value0[j]);
			}
			printf("\n");
			printf("value_min: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.value_min[j]);
			}
			printf("\n");
			printf("value_max: ");
			for (int j = 0; j < 3; j++) {
				printf("%8.4f ",(double)container.value_max[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"actuator_controls_3",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_controls_3));
		ID = ORB_ID(actuator_controls_3);
		struct actuator_controls_3_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_controls_3 #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_sample: %" PRIu64 "\n",container.timestamp_sample);
			printf("control: ");
			for (int j = 0; j < 8; j++) {
				printf("%8.4f ",(double)container.control[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"mc_att_ctrl_status",50) == 0) {
		sub = orb_subscribe(ORB_ID(mc_att_ctrl_status));
		ID = ORB_ID(mc_att_ctrl_status);
		struct mc_att_ctrl_status_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: mc_att_ctrl_status #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("roll_rate_integ: %8.4f\n",(double)container.roll_rate_integ);
			printf("pitch_rate_integ: %8.4f\n",(double)container.pitch_rate_integ);
			printf("yaw_rate_integ: %8.4f\n",(double)container.yaw_rate_integ);
			}
		}
	} else if (strncmp(argv[1],"distance_sensor",50) == 0) {
		sub = orb_subscribe(ORB_ID(distance_sensor));
		ID = ORB_ID(distance_sensor);
		struct distance_sensor_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: distance_sensor #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("min_distance: %8.4f\n",(double)container.min_distance);
			printf("max_distance: %8.4f\n",(double)container.max_distance);
			printf("current_distance: %8.4f\n",(double)container.current_distance);
			printf("covariance: %8.4f\n",(double)container.covariance);
			printf("type: %u\n",(unsigned)container.type);
			printf("id: %u\n",(unsigned)container.id);
			printf("orientation: %u\n",(unsigned)container.orientation);
			}
		}
	} else if (strncmp(argv[1],"rc_channels",50) == 0) {
		sub = orb_subscribe(ORB_ID(rc_channels));
		ID = ORB_ID(rc_channels);
		struct rc_channels_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: rc_channels #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("timestamp_last_valid: %" PRIu64 "\n",container.timestamp_last_valid);
			printf("channels: ");
			for (int j = 0; j < 18; j++) {
				printf("%8.4f ",(double)container.channels[j]);
			}
			printf("\n");
			printf("channel_count: %u\n",(unsigned)container.channel_count);
			printf("rssi: %u\n",(unsigned)container.rssi);
			printf("signal_lost: %s\n",container.signal_lost ? "True" : "False");
			printf("frame_drop_count: %u\n",container.frame_drop_count);
			}
		}
	} else if (strncmp(argv[1],"sensor_gyro",50) == 0) {
		sub = orb_subscribe(ORB_ID(sensor_gyro));
		ID = ORB_ID(sensor_gyro);
		struct sensor_gyro_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: sensor_gyro #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("integral_dt: %" PRIu64 "\n",container.integral_dt);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("x_integral: %8.4f\n",(double)container.x_integral);
			printf("y_integral: %8.4f\n",(double)container.y_integral);
			printf("z_integral: %8.4f\n",(double)container.z_integral);
			printf("temperature: %8.4f\n",(double)container.temperature);
			printf("range_rad_s: %8.4f\n",(double)container.range_rad_s);
			printf("scaling: %8.4f\n",(double)container.scaling);
			printf("x_raw: %d\n",(int)container.x_raw);
			printf("y_raw: %d\n",(int)container.y_raw);
			printf("z_raw: %d\n",(int)container.z_raw);
			printf("temperature_raw: %d\n",(int)container.temperature_raw);
			}
		}
	} else if (strncmp(argv[1],"subsystem_info",50) == 0) {
		sub = orb_subscribe(ORB_ID(subsystem_info));
		ID = ORB_ID(subsystem_info);
		struct subsystem_info_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: subsystem_info #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("present: %s\n",container.present ? "True" : "False");
			printf("enabled: %s\n",container.enabled ? "True" : "False");
			printf("ok: %s\n",container.ok ? "True" : "False");
			printf("subsystem_type: %" PRIu64 "\n",container.subsystem_type);
			}
		}
	} else if (strncmp(argv[1],"actuator_direct",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_direct));
		ID = ORB_ID(actuator_direct);
		struct actuator_direct_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_direct #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("nvalues: %u\n",container.nvalues);
			printf("values: ");
			for (int j = 0; j < 16; j++) {
				printf("%8.4f ",(double)container.values[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"vehicle_gps_position",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_gps_position));
		ID = ORB_ID(vehicle_gps_position);
		struct vehicle_gps_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_gps_position #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp_position: %" PRIu64 "\n",container.timestamp_position);
			printf("lat: %d\n",container.lat);
			printf("lon: %d\n",container.lon);
			printf("alt: %d\n",container.alt);
			printf("alt_ellipsoid: %d\n",container.alt_ellipsoid);
			printf("timestamp_variance: %" PRIu64 "\n",container.timestamp_variance);
			printf("s_variance_m_s: %8.4f\n",(double)container.s_variance_m_s);
			printf("c_variance_rad: %8.4f\n",(double)container.c_variance_rad);
			printf("fix_type: %u\n",(unsigned)container.fix_type);
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			printf("hdop: %8.4f\n",(double)container.hdop);
			printf("vdop: %8.4f\n",(double)container.vdop);
			printf("noise_per_ms: %d\n",container.noise_per_ms);
			printf("jamming_indicator: %d\n",container.jamming_indicator);
			printf("timestamp_velocity: %" PRIu64 "\n",container.timestamp_velocity);
			printf("vel_m_s: %8.4f\n",(double)container.vel_m_s);
			printf("vel_n_m_s: %8.4f\n",(double)container.vel_n_m_s);
			printf("vel_e_m_s: %8.4f\n",(double)container.vel_e_m_s);
			printf("vel_d_m_s: %8.4f\n",(double)container.vel_d_m_s);
			printf("cog_rad: %8.4f\n",(double)container.cog_rad);
			printf("vel_ned_valid: %s\n",container.vel_ned_valid ? "True" : "False");
			printf("timestamp_time: %" PRIu64 "\n",container.timestamp_time);
			printf("time_utc_usec: %" PRIu64 "\n",container.time_utc_usec);
			printf("satellites_used: %u\n",(unsigned)container.satellites_used);
			}
		}
	} else if (strncmp(argv[1],"vehicle_control_mode",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_control_mode));
		ID = ORB_ID(vehicle_control_mode);
		struct vehicle_control_mode_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_control_mode #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("flag_armed: %s\n",container.flag_armed ? "True" : "False");
			printf("flag_external_manual_override_ok: %s\n",container.flag_external_manual_override_ok ? "True" : "False");
			printf("flag_system_hil_enabled: %s\n",container.flag_system_hil_enabled ? "True" : "False");
			printf("flag_control_manual_enabled: %s\n",container.flag_control_manual_enabled ? "True" : "False");
			printf("flag_control_auto_enabled: %s\n",container.flag_control_auto_enabled ? "True" : "False");
			printf("flag_control_offboard_enabled: %s\n",container.flag_control_offboard_enabled ? "True" : "False");
			printf("flag_control_rates_enabled: %s\n",container.flag_control_rates_enabled ? "True" : "False");
			printf("flag_control_attitude_enabled: %s\n",container.flag_control_attitude_enabled ? "True" : "False");
			printf("flag_control_force_enabled: %s\n",container.flag_control_force_enabled ? "True" : "False");
			printf("flag_control_velocity_enabled: %s\n",container.flag_control_velocity_enabled ? "True" : "False");
			printf("flag_control_position_enabled: %s\n",container.flag_control_position_enabled ? "True" : "False");
			printf("flag_control_altitude_enabled: %s\n",container.flag_control_altitude_enabled ? "True" : "False");
			printf("flag_control_climb_rate_enabled: %s\n",container.flag_control_climb_rate_enabled ? "True" : "False");
			printf("flag_control_termination_enabled: %s\n",container.flag_control_termination_enabled ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"vehicle_command",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_command));
		ID = ORB_ID(vehicle_command);
		struct vehicle_command_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_command #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("param1: %8.4f\n",(double)container.param1);
			printf("param2: %8.4f\n",(double)container.param2);
			printf("param3: %8.4f\n",(double)container.param3);
			printf("param4: %8.4f\n",(double)container.param4);
			printf("param5: %8.4f\n",(double)container.param5);
			printf("param6: %8.4f\n",(double)container.param6);
			printf("param7: %8.4f\n",(double)container.param7);
			printf("command: %u\n",container.command);
			printf("target_system: %u\n",container.target_system);
			printf("target_component: %u\n",container.target_component);
			printf("source_system: %u\n",container.source_system);
			printf("source_component: %u\n",container.source_component);
			printf("confirmation: %u\n",(unsigned)container.confirmation);
			}
		}
	} else if (strncmp(argv[1],"vehicle_global_position",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_global_position));
		ID = ORB_ID(vehicle_global_position);
		struct vehicle_global_position_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_global_position #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("time_utc_usec: %" PRIu64 "\n",container.time_utc_usec);
			printf("lat: %8.4f\n",(double)container.lat);
			printf("lon: %8.4f\n",(double)container.lon);
			printf("alt: %8.4f\n",(double)container.alt);
			printf("vel_n: %8.4f\n",(double)container.vel_n);
			printf("vel_e: %8.4f\n",(double)container.vel_e);
			printf("vel_d: %8.4f\n",(double)container.vel_d);
			printf("yaw: %8.4f\n",(double)container.yaw);
			printf("eph: %8.4f\n",(double)container.eph);
			printf("epv: %8.4f\n",(double)container.epv);
			printf("terrain_alt: %8.4f\n",(double)container.terrain_alt);
			printf("terrain_alt_valid: %s\n",container.terrain_alt_valid ? "True" : "False");
			printf("dead_reckoning: %s\n",container.dead_reckoning ? "True" : "False");
			printf("pressure_alt: %8.4f\n",(double)container.pressure_alt);
			}
		}
	} else if (strncmp(argv[1],"vehicle_force_setpoint",50) == 0) {
		sub = orb_subscribe(ORB_ID(vehicle_force_setpoint));
		ID = ORB_ID(vehicle_force_setpoint);
		struct vehicle_force_setpoint_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: vehicle_force_setpoint #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("x: %8.4f\n",(double)container.x);
			printf("y: %8.4f\n",(double)container.y);
			printf("z: %8.4f\n",(double)container.z);
			printf("yaw: %8.4f\n",(double)container.yaw);
			}
		}
	} else if (strncmp(argv[1],"navigation_capabilities",50) == 0) {
		sub = orb_subscribe(ORB_ID(navigation_capabilities));
		ID = ORB_ID(navigation_capabilities);
		struct navigation_capabilities_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: navigation_capabilities #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("turn_distance: %8.4f\n",(double)container.turn_distance);
			printf("landing_horizontal_slope_displacement: %8.4f\n",(double)container.landing_horizontal_slope_displacement);
			printf("landing_slope_angle_rad: %8.4f\n",(double)container.landing_slope_angle_rad);
			printf("landing_flare_length: %8.4f\n",(double)container.landing_flare_length);
			printf("abort_landing: %s\n",container.abort_landing ? "True" : "False");
			}
		}
	} else if (strncmp(argv[1],"actuator_outputs",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_outputs));
		ID = ORB_ID(actuator_outputs);
		struct actuator_outputs_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_outputs #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("noutputs: %u\n",container.noutputs);
			printf("output: ");
			for (int j = 0; j < 16; j++) {
				printf("%8.4f ",(double)container.output[j]);
			}
			printf("\n");
			}
		}
	} else if (strncmp(argv[1],"differential_pressure",50) == 0) {
		sub = orb_subscribe(ORB_ID(differential_pressure));
		ID = ORB_ID(differential_pressure);
		struct differential_pressure_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: differential_pressure #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("error_count: %" PRIu64 "\n",container.error_count);
			printf("differential_pressure_raw_pa: %8.4f\n",(double)container.differential_pressure_raw_pa);
			printf("differential_pressure_filtered_pa: %8.4f\n",(double)container.differential_pressure_filtered_pa);
			printf("max_differential_pressure_pa: %8.4f\n",(double)container.max_differential_pressure_pa);
			printf("temperature: %8.4f\n",(double)container.temperature);
			}
		}
	} else if (strncmp(argv[1],"airspeed",50) == 0) {
		sub = orb_subscribe(ORB_ID(airspeed));
		ID = ORB_ID(airspeed);
		struct airspeed_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: airspeed #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("indicated_airspeed_m_s: %8.4f\n",(double)container.indicated_airspeed_m_s);
			printf("true_airspeed_m_s: %8.4f\n",(double)container.true_airspeed_m_s);
			printf("true_airspeed_unfiltered_m_s: %8.4f\n",(double)container.true_airspeed_unfiltered_m_s);
			printf("air_temperature_celsius: %8.4f\n",(double)container.air_temperature_celsius);
			printf("confidence: %8.4f\n",(double)container.confidence);
			}
		}
	} else if (strncmp(argv[1],"actuator_armed",50) == 0) {
		sub = orb_subscribe(ORB_ID(actuator_armed));
		ID = ORB_ID(actuator_armed);
		struct actuator_armed_s container;
		memset(&container, 0, sizeof(container));
		bool updated;
		unsigned i = 0;
		while(i < num_msgs) {
			orb_check(sub,&updated);
			if (i == 0) { updated = true; } else { usleep(500); }
			i++;
			if (updated) {
		printf("\nTOPIC: actuator_armed #%d\n", i);
			orb_copy(ID,sub,&container);
			printf("timestamp: %" PRIu64 "\n",container.timestamp);
			printf("armed: %s\n",container.armed ? "True" : "False");
			printf("prearmed: %s\n",container.prearmed ? "True" : "False");
			printf("ready_to_arm: %s\n",container.ready_to_arm ? "True" : "False");
			printf("lockdown: %s\n",container.lockdown ? "True" : "False");
			printf("force_failsafe: %s\n",container.force_failsafe ? "True" : "False");
			printf("in_esc_calibration_mode: %s\n",container.in_esc_calibration_mode ? "True" : "False");
			}
		}
	} else {
		 printf(" Topic did not match any known topics\n");
	}
		orb_unsubscribe(sub);
	 return 0;
}
